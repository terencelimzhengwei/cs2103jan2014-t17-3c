//@author: a0097330h



	/**
	 * origin: D:\TiMEWiSE\TimeWiseLogic\Storage.cpp
	 */

#include "Storage.h"

Storage::Storage(void) {
	_logger = Logger::getLogger();
	_undoneFileName = UNDONE_TASK_TEXTFILE;
	_doneFileName = DONE_TASK_TEXTFILE;
	_corrupted=false;
}

Storage::~Storage(void) {
}

void Storage::saveFile(TaskList& listOfTasks) { 
	_logger->log(LOG_MESSAGE_STORAGE, LOG_MESSAGE_SAVING);
	saveUndoneTasks(listOfTasks);
	saveDoneTasks(listOfTasks);
}

void Storage::retrieveFile(TaskList& listOfTasks) { 
	_logger->log(LOG_MESSAGE_STORAGE, LOG_MESSAGE_RETRIEVAL);
	retrieveUndoneTasks(listOfTasks);
	retrieveDoneTasks(listOfTasks);
}

void Storage::saveUndoneTasks(TaskList& listOfTasks) {
	std::ofstream writeFile(_undoneFileName);
	for(unsigned int i = 0; i < listOfTasks.undoneSize(); i++) { 
		writeFile << DESCRIPTION_FIELD << listOfTasks.getTask(i)->getDescription();
		writeFile << NEW_LINE << START_DATE_FIELD;
		if(listOfTasks.getTask(i)->getStartDate() != NULL) {
			writeFile<< listOfTasks.getTask(i)->getStartDate()->toFormat();
		}
		writeFile << NEW_LINE << END_DATE_FIELD;
		if(listOfTasks.getTask(i)->getEndDate() != NULL) {
			writeFile << listOfTasks.getTask(i)->getEndDate()->toFormat();
		}
		writeFile << NEW_LINE << START_TIME_FIELD;
		if(listOfTasks.getTask(i)->getStartTime() != NULL) {
			writeFile << listOfTasks.getTask(i)->getStartTime()->toString();
		}
		writeFile << NEW_LINE << END_TIME_FIELD;
		if(listOfTasks.getTask(i)->getEndTime() != NULL) {
			writeFile << listOfTasks.getTask(i)->getEndTime()->toString();
		}
		writeFile << NEW_LINE
			<< CATEGORY_FIELD << listOfTasks.getTask(i)->getTaskCategory()
			<< NEW_LINE
			<< STATUS_FIELD << TASK_STATUS_STRING[listOfTasks.getTask(i)->getTaskStatus()] 
			<< NEW_LINE;

		writeFile << SEPARATOR;
		if(i != listOfTasks.undoneSize() - REDUCTION_VALUE) {
			writeFile << std::endl;
		}
	} 
}

void Storage::saveDoneTasks(TaskList& listOfTasks){
	std::ofstream writeFile(_doneFileName);
	for(unsigned int i = 0; i < listOfTasks.doneSize(); i++) { 
		writeFile << DESCRIPTION_FIELD << listOfTasks.getCompletedTask(i)->getDescription();
		writeFile  << NEW_LINE << START_DATE_FIELD;
		if(listOfTasks.getCompletedTask(i)->getStartDate() != NULL){
			writeFile << listOfTasks.getCompletedTask(i)->getStartDate()->toFormat();
		}
		writeFile << NEW_LINE << END_DATE_FIELD;
		if(listOfTasks.getCompletedTask(i)->getEndDate() != NULL){
			writeFile << listOfTasks.getCompletedTask(i)->getEndDate()->toFormat();
		}
		writeFile << NEW_LINE <<  START_TIME_FIELD;
		if(listOfTasks.getCompletedTask(i)->getStartTime() != NULL){
			writeFile << listOfTasks.getCompletedTask(i)->getStartTime()->toString();
		}
		writeFile << NEW_LINE << END_TIME_FIELD;
		if(listOfTasks.getCompletedTask(i)->getEndTime() != NULL){
			writeFile << listOfTasks.getCompletedTask(i)->getEndTime()->toString();
		}
		writeFile << NEW_LINE 
			<< CATEGORY_FIELD << listOfTasks.getCompletedTask(i)->getTaskCategory() 
			<< NEW_LINE
			<< "Status: " << TASK_STATUS_STRING[listOfTasks.getCompletedTask(i)->getTaskStatus()] 
			<< NEW_LINE;
		
		writeFile << SEPARATOR;
		if(i != listOfTasks.undoneSize() - REDUCTION_VALUE) {
			writeFile << std::endl;
		}
	} 
}

//Retrieves information of done tasks.
void Storage::retrieveDoneTasks(TaskList& listOfTasks) {
	std::string userInput = DEFAULT_EMPTY;
	std::ifstream input(_doneFileName);
	std::string temp;
	int taskHeader;

	if(input.is_open()) {
		while(!input.eof()) {
			taskHeader = START_VALUE;
			getline(input,userInput);
			if(userInput == DEFAULT_EMPTY) {
				return;
			}
			Task* newTask = new Task;
			while (userInput != SEPARATOR) {
				std::string details = Parser::removeFirstWord(userInput);
				details = Parser::trim(details);
				switch(taskHeader) {
				case HEADER_DESCRIPTION: {
					newTask->setDescription(details);
					taskHeader++;
					break;
				}
				case HEADER_START_DATE: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try{
							newTask->setStartDate(_parser.createDate(details));
						} catch(...) {
							delete newTask->getStartDate();
							newTask->setStartDate(NULL);
							_corrupted=true;
						}
					}
					break;
				}
				case HEADER_END_DATE: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setEndDate(_parser.createDate(details));
						} catch(...) {
							delete newTask->getEndDate();
							newTask->setEndDate(NULL);
							_corrupted=true;
						}					
					} break;
				}
				case HEADER_START_TIME: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setStartTime(_parser.createTime(details));
						} catch(...) {
							delete newTask->getStartTime();
							newTask->setStartTime(NULL);
							_corrupted=true;
						}						
					}
					break;
				}
				case HEADER_END_TIME: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setEndTime(_parser.createTime(details));
						} catch(...) {
							delete newTask->getEndTime();
							newTask->setEndTime(NULL);
							_corrupted=true;
						}						
					} 
					break;
				}
				case HEADER_CATEGORY: {
					taskHeader++;
					newTask->setCategory(details);
					break;
				}
				case HEADER_STATUS: {
					taskHeader++;
					TASK_STATUS status = _parser.getTaskStatus(details);
					newTask->setStatusAsDone();
					break;
				}
				default: {
					_corrupted = true;
					break;
				}
				}
				if(taskHeader > COLUMN_OUT_OF_BOUND) {
					break;
				}
				getline(input, userInput);
			} 
			listOfTasks.addTaskToDoneList(*newTask);
		} 
	}
	input.close();
}

//Retrieves information of uncompleted tasks.
void Storage::retrieveUndoneTasks(TaskList& listOfTasks) {
	std::string userInput = DEFAULT_EMPTY;
	std::ifstream input(_undoneFileName);
	std::string temp;
	int taskHeader;

	if(input.is_open()) {
		while(!input.eof()) {
			taskHeader = START_VALUE;
			getline(input,userInput);
			if(userInput == DEFAULT_EMPTY) {
				return;
			}
			Task* newTask = new Task;

			while (userInput != SEPARATOR) {
				std::string details = _parser.removeFirstWord(userInput);
				details = Parser::trim(details);

				switch(taskHeader){
				case HEADER_DESCRIPTION : {
					newTask->setDescription(details);
					taskHeader++;
					break;
				}
				case HEADER_START_DATE: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setStartDate(_parser.createDate(details));
						} catch(...) {
							delete newTask->getStartDate();
							newTask->setStartDate(NULL);
							_corrupted=true;
						}
					}
					break;
				}
				case HEADER_END_DATE: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setEndDate(_parser.createDate(details));
						} catch(...) {
							delete newTask->getEndDate();
							newTask->setEndDate(NULL);
							_corrupted=true;
						}					
					}
					break;
				}
				case HEADER_START_TIME: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setStartTime(_parser.createTime(details));
						} catch(...) {
							delete newTask->getStartTime();
							newTask->setStartTime(NULL);
							_corrupted=true;
						}						
					}
					break;
				}
				case HEADER_END_TIME: {
					taskHeader++;
					if(details == DEFAULT_EMPTY || details == SPACE_PARAMETER) {
						break;
					} else {
						try {
							newTask->setEndTime(_parser.createTime(details));
						} catch(...) {
							delete newTask->getEndTime();
							newTask->setEndTime(NULL);
							_corrupted=true;
						}						
					}
					break;
				}
				case HEADER_CATEGORY: {
					taskHeader++;
					newTask->setCategory(details);
					break;
				}
				case HEADER_STATUS: {
					taskHeader++;
					TASK_STATUS status =_parser.getTaskStatus(details);
					if(status == DONE) {
						newTask->setStatusAsDone();
						break;
					} else if(status == UNCOMPLETED) {
						newTask->setStatusasUndone();
						break;
					} else if(status == OVERDUE) {
						newTask->setStatusAsOverdue();
						break;
					} else {
						_corrupted = true;
						break;
					}
				}
				default:
					_corrupted = true;
					break;
				}
				if(taskHeader > COLUMN_OUT_OF_BOUND) {
					break;
				}
				getline(input, userInput);
			} 
			listOfTasks.addTask(*newTask);
		} 
	}
	input.close();
}

bool Storage::isCorrupted(){
	return _corrupted;
}

	// End of segment: D:\TiMEWiSE\TimeWiseLogic\Storage.cpp





	/**
	 * origin: D:\TiMEWiSE\TimeWiseLogic\Storage.h
	 */

#ifndef STORAGE_H
#define STORAGE_H

#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include "Constants.h"
#include "Logger.h"
#include "Parser.h"
#include "TaskList.h"

class Storage{
public:
	Storage(void);
	~Storage(void);

	void retrieveFile(TaskList&);
	void saveFile(TaskList&);
	bool isCorrupted();

private:
	std::string _undoneFileName;
	std::string _doneFileName;
	Parser _parser;
	bool _corrupted;
	Logger* _logger;

	void saveUndoneTasks(TaskList&);
	void saveDoneTasks(TaskList&);
	void retrieveDoneTasks(TaskList&);
	void retrieveUndoneTasks(TaskList&);

};
#endif
	// End of segment: D:\TiMEWiSE\TimeWiseLogic\Storage.h





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\Constants_ui.h
	 */

#ifndef CONSTANTS_UI_H
#define CONSTANTS_UI_H

#include <string>

namespace {
	const char* ADD_COMMAND            = "add";
	const char* CLEAR_COMMAND          = "clear";
	const char* DELETE_COMMAND         = "delete";
	const char* DISPLAY_COMMAND        = "display";
	const char* DONE_COMMAND           = "done";
	const char* EDIT_COMMAND           = "edit";
	const char* EXIT_COMMAND           = "exit";
	const char* FILTER_COMMAND         = "filter";
	const char* HELP_COMMAND           = "help";
	const char* SEARCH_COMMAND         = "search";
	const char* UNDONE_COMMAND		   = "undone";
	const char* UNDO_COMMAND           = "undo";
	const char* REDO_COMMAND           = "redo";

	const char* ADD_FORMAT             = "add <description> <start date> <start time> <end date> <end time> <#category>";
	const char* CLEAR_FORMAT           = "clear or clear all / main / completed";
	const char* DELETE_FORMAT          = "delete <ID> / multiple <IDs>";
	const char* DISPLAY_FORMAT         = "display main / done";
	const char* DONE_FORMAT            = "done <IDs> / multiple <IDs>";
	const char* EDIT_FORMAT            = "edit <ID> <contents>";
	const char* FILTER_FORMAT          = "filter <dates> / <#category>";
	const char* SEARCH_FORMAT          = "search <keywords>";
	const char* UNDONE_FORMAT		   = "undone <IDs> / multiple <IDs>";
	const char* DEFAULT_DISPLAY        = "You may: Add, Clear, Delete, Display, Done/Undone, Edit, Filter, Search, Undo/Redo, Help, Exit";
	const std::string OVERDUE_REMINDER = "Reminder! You have %d overdue task(s).";
	const char* EMPTY_INPUT			   = "Please enter a command.";
	const char* CORRUPTED_MESSAGE      = "<font color='red'>Error! Task details may have been lost/altered due to tampering of the text file!</font>";
	const char* OUT_OF_BOUNDS          = "Out of bounds";

	const char* BLANK                  = "";
	const char* SPACE                  = " ";
	const char* MAIN_TITLE             = "Your Tasks";
	const char* COMPLETED_TITLE        = "Completed Tasks";
	const char* SEARCHED_TITLE         = "Searched Tasks";
	const char* FILTERED_TITLE         = "Filtered Tasks";

	const char* OVERDUE_STATUS         = "overdue";
	const char* DONE_STATUS            = "done";

	const char* DISPLAY_MAIN           = "display main";
	const char* DISPLAY_DONE           = "display done";

	const char* CLEAR_ALL			   = "clear all";
	const char* CLEAR_MAIN			   = "clear main";
	const char* CLEAR_COMPLETED		   = "clear completed";

	//Values pertaining to table model configuration
	const int COLUMN_DESCRIPTION        = 0;
	const int COLUMN_DAY		        = 1;
	const int COLUMN_START_DATE		    = 2;
	const int COLUMN_START_TIME         = 3;
	const int COLUMN_END_DATE           = 4;
	const int COLUMN_END_TIME           = 5;
	const int COLUMN_CATEGORY           = 6;
	const int COLUMN_COUNT              = 7;
	const int COLUMN_DESC_WIDTH         = 185;
	const int COLUMN_DAY_WIDTH          = 45;
	const int COLUMN_START_DATE_WIDTH   = 55;
	const int COLUMN_START_TIME_WIDTH   = 48;
	const int COLUMN_END_DATE_WIDTH     = 55;
	const int COLUMN_END_TIME_WIDTH     = 48;
	const int COLUMN_CATEGORY_WIDTH     = 55;
	const int TOTAL_WIDTH               = 535;
	const int ROW_HEIGHT                = 27;

	const char* DESCRIPTION_HEADER = "Description";
	const char* DAY_HEADER         = "Day" ;
	const char* START_DATE_HEADER  = "S. Date";
	const char* START_TIME_HEADER  = "S. Time";
	const char* END_DATE_HEADER    = "E. Date";
	const char* END_TIME_HEADER    = "E. Time";
	const char* CAT_HEADER         = "Category";

	//Strings pertaining to Fonts
	const char* FONT_CF_JACK_STORY = ":/TimeWiseGUI/CFJackStory-Regular.ttf";
	const char* FONT_EHSMB         = ":/TimeWiseGUI/EHSMB.TTF";
	const char* FONT_NEW_CICLE     = ":/TimeWiseGUI/New Cicle Semi.ttf";
	const char* FONT_EHSMB_NAME    = "Electronic Highway Sign";

	//Values Pertaining to Font Sizes and Boldness
	const int DATE_SIZE        = 19;
	const int TIME_SIZE        = 14;
	const int BOLD             = 75;
	const int BOLDEST          = 99;
	const int BOLDED_FONT_SIZE = 9;

	//Hotkey strings
	const char* HOTKEY_F1 = "F1";
	const char* HOTKEY_F2 = "F2";
	const char* HOTKEY_F3 = "F3";
	const char* HOTKEY_F4 = "F4";

	//Colour Indices for highlighting rows
	const int OVERDUE_R_INDEX            = 255;
	const int OVERDUE_G_INDEX            = 0;
    const int OVERDUE_B_INDEX            = 0;
	const int OVERDUE_TRANSPARENCY_INDEX = 50;
	const int COMPLETED_R_INDEX          = 146;
	const int COMPLETED_G_INDEX          = 255;
	const int COMPLETED_B_INDEX          = 192;
	const int CLASH_R_INDEX              = 254;
	const int CLASH_G_INDEX              = 255;
	const int CLASH_B_INDEX              = 185;

	//Miscellaneous
	const int ADJUSTMENT_VALUE   = 1;
	const int NOUGHT             = 0;
	const int MAX_LETTERS        = 256;
	char buffer[MAX_LETTERS];
}
#endif
	// End of segment: D:\TiMEWiSE\TimeWiseGUI\Constants_ui.h





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\main.cpp
	 */

#include <QtWidgets/QApplication>
#include "timewisegui.h"

int main(int argc, char *argv[]) {
	QApplication a(argc, argv);
	TimeWiseGUI w;
	w.show();
	return a.exec();
}

	// End of segment: D:\TiMEWiSE\TimeWiseGUI\main.cpp





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewiseClock.cpp
	 */

#include "timewiseclock.h"

TimeWiseClock::TimeWiseClock() {
	_date = QDate::currentDate();
	_time = QTime::currentTime();
}

TimeWiseClock::~TimeWiseClock() {
}

QString TimeWiseClock::dateToString(){
	return _date.toString();
}

QString TimeWiseClock::timeToString(){
	return _time.toString();
}
	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewiseClock.cpp





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewiseClock.h
	 */

#ifndef TIMEWISECLOCK_H
#define TIMEWISECLOCK_H

//============================================================
// This class is responsible for configuring a clock object
// whose date and time will be displayed in the main ui.
//============================================================
#include <QDate>
#include <QString>
#include <QTime>

class TimeWiseClock {
public:
	TimeWiseClock();
	~TimeWiseClock();
	QString dateToString();
	QString timeToString();

private:
	QDate _date;
	QTime _time;
};
#endif


	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewiseClock.h





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewisegui.cpp
	 */

#include "timewisegui.h"

TimeWiseGUI::TimeWiseGUI(QWidget *parent): QMainWindow(parent) {
	ui.setupUi(this);

	configureTable();
	setupClock();
	setupFont();
	setupHotKeys();
	autoComplete();

	//set cursor to userInput box as soon as program is opened.
	QTimer::singleShot(NOUGHT, ui.userInput, SLOT(setFocus()));

	//remove title header of main window
	this->setWindowFlags(Qt::CustomizeWindowHint);

	ui.userInput->installEventFilter(this);

	//displays number of overdue tasks (if any) as soon as program is opened.
	setOverdueMessage();

	//informs user if text file is tampered.
	checkCorrupted();

}

TimeWiseGUI::~TimeWiseGUI() {
}

//========================================================
//       USER INPUT BOX - WHEN TEXT CHANGES [SLOT]
//========================================================
//As user types in user input box, guide changes to show different command formats.
void TimeWiseGUI::on_userInput_textChanged() {
	if(ui.userInput->text() == ADD_COMMAND) {
		ui.label_help->setText(ADD_FORMAT);
	} else if(ui.userInput->text() == CLEAR_COMMAND) {
		ui.label_help->setText(CLEAR_FORMAT);
	} else if(ui.userInput->text() == DELETE_COMMAND) {
		ui.label_help->setText(DELETE_FORMAT);
	} else if(ui.userInput->text() == DISPLAY_COMMAND) {
		ui.label_help->setText(DISPLAY_FORMAT);
	} else if(ui.userInput->text() == DONE_COMMAND) {
		ui.label_help->setText(DONE_FORMAT);
	} else if(ui.userInput->text() == EDIT_COMMAND) {
		ui.label_help->setText(EDIT_FORMAT);
	} else if(ui.userInput->text() == FILTER_COMMAND) {
		ui.label_help->setText(FILTER_FORMAT);
	} else if(ui.userInput->text() == SEARCH_COMMAND) {
		ui.label_help->setText(SEARCH_FORMAT);
	} else if(ui.userInput->text() == UNDONE_COMMAND) {
		ui.label_help->setText(UNDONE_FORMAT);
	} else if(ui.userInput->text() == BLANK) {
		ui.label_help->setText(DEFAULT_DISPLAY);
	}
}

//========================================================
//     USER INPUT BOX - WHEN 'ENTER' IS PRESSED [SLOT]
//========================================================
void TimeWiseGUI::on_userInput_returnPressed() {
	QString input = ui.userInput->text();

	if(input == HELP_COMMAND) {
		showHelp();
	} else if(input == EXIT_COMMAND) {
		exit(0);
	} else {
		//Stores user inputs into a QStringList for retrieval later when key up or down is pressed
		lines << input;
		current_line = lines.size();
		emit lineExecuted(lines.back());
		
		try {
			checkEmpty(input);

		    std::string userCommand = input.toLocal8Bit().constData();   //converts QString to string type.
			std::string messageLog = _logic.processCommand(userCommand); //sends user input (string) to logic for processing.
			QString outputMessage = QString::fromStdString(messageLog);  //converts string to QString type.
			ui.label_mlog->setText(outputMessage);                       //displays feedback.

			autoComplete();

			DISPLAY_TYPE displayType = _logic.getScreenToDisplay();
			displayTaskList(displayType);
		}
		catch(const std::invalid_argument& e) {
			ui.label_mlog->setText(e.what());
		}
	}
	ui.userInput->setText(BLANK);
}

//========================================================
//				MANAGE PAGE TO DISPLAY
//		[Main, Search, Filtered, Completed]
//========================================================
void TimeWiseGUI::displayTaskList(DISPLAY_TYPE displayType) {
	switch(displayType){
	case MAIN: {
		createMainTable();
		ui.label_title->setText(MAIN_TITLE);
		break;
	}
	case SEARCHED: {
		vector<Task*> taskList = _logic.getTaskList().getSearchResults();
		createOtherTables(taskList);
		ui.label_title->setText(SEARCHED_TITLE);
		break;
	}
	case COMPLETE:{
		vector<Task*> taskList = _logic.getTaskList().getCompletedTaskList();
		createOtherTables(taskList);
		ui.label_title->setText(COMPLETED_TITLE);
		break;
	}
	case FILTERED:{
		vector<Task*> taskList = _logic.getTaskList().getFilterResults();
		createOtherTables(taskList);
		ui.label_title->setText(FILTERED_TITLE);
		break;
	}
	}
}

//========================================================
//			MANAGES DATA AND SET IT INTO TABLE 
//						(MAIN PAGE)
//========================================================
void TimeWiseGUI::createMainTable() {
	//clears the contents in the table before displaying updated taskList
	model->removeRows(NOUGHT, model->rowCount());

	TaskList taskList = _logic.getTaskList();
	vector<int> boldedIndices;
	
	//displays an image if table is empty; else, conceal it.
	if(taskList.undoneSize() == NOUGHT) {
		ui.emptyLogo->show();
	} else {
		ui.emptyLogo->hide();
	}

	setMainData(taskList, boldedIndices);
	
	//scrolls to latest task after all tasks have been set in table.
	if(!boldedIndices.empty()) {
		ui.tableView->scrollTo(model->index(boldedIndices[NOUGHT], NOUGHT));
	}
}

//puts the data in place in the table. Bolds/highlights rows, if necessary
void TimeWiseGUI::setMainData(TaskList& taskList, vector<int>& boldedIndices) {
	boldedIndices = taskList.getBoldIndexList();
	
	//goes through each cell in the table and sets every attributes of every task into the respective cells.
	for(int row = 0; row < taskList.undoneSize(); row++) {
		for(int column = 0; column < COLUMN_COUNT; column++) {
			//add row for every task in taskList dynamically
			model->setRowCount(row + ADJUSTMENT_VALUE);

			QStandardItem* item;
			switch (column) {
			case COLUMN_DESCRIPTION: {
				std::string taskDescription = (taskList.getTask(row))->getDescription();
				QString qTask = QString::fromStdString(taskDescription);
				item = new QStandardItem(qTask);
				break;
			}
			case COLUMN_DAY: {
				std::string taskDay = taskList.getTask(row)->getDayString();
				QString qDay = QString::fromStdString(taskDay);
				item = new QStandardItem(qDay);
				break;
			}
			case COLUMN_START_DATE: {
				if(taskList.getTask(row)->getStartDate()!=NULL){
					std::string taskStartDate = taskList.getTask(row)->getStartDate()->toString();
					QString qStartDate = QString::fromStdString(taskStartDate);
					item = new QStandardItem(qStartDate);
				}
				break;
			}
			case COLUMN_START_TIME: {
				if(taskList.getTask(row)->getStartTime()!=NULL){
					std::string taskStartTime = taskList.getTask(row)->getStartTime()->toString();
					QString qStartTime = QString::fromStdString(taskStartTime);
					item = new QStandardItem(qStartTime);
				}
				break;
			}
			case COLUMN_END_DATE: {
				if(taskList.getTask(row)->getEndDate()!=NULL){
					std::string taskEndDate = taskList.getTask(row)->getEndDate()->toString();
					QString qEndDate = QString::fromStdString(taskEndDate);
					item = new QStandardItem(qEndDate);
				}
				break;
			}
			case COLUMN_END_TIME: {
				if(taskList.getTask(row)->getEndTime()!=NULL){
					std::string taskEndTime = taskList.getTask(row)->getEndTime()->toString();
					QString qEndTime = QString::fromStdString(taskEndTime);
					item = new QStandardItem(qEndTime);
				}
				break;
			}
			case COLUMN_CATEGORY: {
				if(taskList.getTask(row)->getTaskCategory()!= BLANK){
					std::string taskCategory= taskList.getTask(row)->getTaskCategory();
					QString qCategory = QString::fromStdString(taskCategory);
					item = new QStandardItem(qCategory);
				}
				break;
			}
			default: {
				ui.label_mlog->setText(OUT_OF_BOUNDS);	
			}
			}
			model->setItem(row, column, item);

			highlightMain(taskList, row, column, boldedIndices);
			boldMain(boldedIndices, row, column);
		}
	}
}

//highlight description in red if status of that task is overdue, in green is status is done, and in yellow if status is clashed.
void TimeWiseGUI::highlightMain(TaskList &taskList, int row, int column, vector<int> &boldedIndices) {
	TASK_STATUS taskStatus = taskList.getTask(row)->getTaskStatus();
	QString qStatus = QString::fromStdString(TASK_STATUS_STRING[taskStatus]);
	QColor rowColorOverdue(OVERDUE_R_INDEX, OVERDUE_G_INDEX, OVERDUE_B_INDEX, OVERDUE_TRANSPARENCY_INDEX);
	QColor rowColorComplete(COMPLETED_R_INDEX, COMPLETED_G_INDEX, COMPLETED_B_INDEX);
	QColor rowColorClash(CLASH_R_INDEX, CLASH_G_INDEX, CLASH_B_INDEX); 

	bool checkClash = taskList.getTask(row)->isClash();
	if(qStatus == OVERDUE_STATUS && checkClash) {
		model->setData(model->index(row, column), rowColorOverdue, Qt::BackgroundRole);
	} else if (qStatus == DONE_STATUS && checkClash) {
		model->setData(model->index(row, column), rowColorComplete, Qt::BackgroundRole);
	} else if (checkClash) {
		model->setData(model->index(row, column), rowColorClash, Qt::BackgroundRole);
	} else if(qStatus == OVERDUE_STATUS) {
		model->setData(model->index(row, column), rowColorOverdue, Qt::BackgroundRole);
	} else if (qStatus == DONE_STATUS) {
		model->setData(model->index(row, column), rowColorComplete, Qt::BackgroundRole);
	}	
}

//bolds entire task if it is the latest task added/edited. Also bolds existing task(s) that clashes with new task added/edited.
void TimeWiseGUI::boldMain(vector<int> &boldedIndices, int row, int column) {
	QFont font;
	font.setBold(false);
	for(int i = 0; i < boldedIndices.size(); i++) {
		if(row == boldedIndices[i]) {
			font.setWeight(BOLDEST);
			font.setPointSize(BOLDED_FONT_SIZE);
		} 
	}
	model->setData(model->index(row,column), font, Qt::FontRole);
}

//========================================================
//			MANAGES DATA AND SET IT INTO TABLE
//		(OTHER PAGES - Searched, Filtered, Completed)
//========================================================
void TimeWiseGUI::createOtherTables(std::vector<Task*>& otherTaskList) {
	//clears the contents in the table before displaying updated taskList
	model->removeRows(NOUGHT, model->rowCount());
	ui.emptyLogo->hide();
	
	vector<int> boldedIndices;
	setOtherData(otherTaskList, boldedIndices);

	//scrolls to latest task after all tasks have been set in table.
	if(!boldedIndices.empty()) {
		ui.tableView->scrollTo(model->index(boldedIndices[NOUGHT], NOUGHT));
	}
}

void TimeWiseGUI::setOtherData(std::vector<Task*>& otherTaskList, vector<int>& boldedIndices) {
	TaskList taskList = _logic.getTaskList();
	boldedIndices = taskList.getBoldIndexList();

	for(int row = 0; row < otherTaskList.size(); row++) {
		for(int column = 0; column < COLUMN_COUNT; column++) {
			//add row for every task in taskList dynamically
			model->setRowCount(row + ADJUSTMENT_VALUE);

			QStandardItem* item;
			switch (column) {
			case COLUMN_DESCRIPTION: {
				std::string taskDescription = (otherTaskList[row])->getDescription();
				QString qTask = QString::fromStdString(taskDescription);
				item = new QStandardItem(qTask);
				break;
			}
			case COLUMN_DAY: {
				std::string taskDay = otherTaskList[row]->getDayString();
				QString qDay = QString::fromStdString(taskDay);
				item = new QStandardItem(qDay);
				break;
			}
			case COLUMN_START_DATE: {			
				if(otherTaskList[row]->getStartDate()!=NULL){
					std::string taskStartDate = otherTaskList[row]->getStartDate()->toString();
					QString qStartDate = QString::fromStdString(taskStartDate);
					item = new QStandardItem(qStartDate);
				}
				break;
			}
			case COLUMN_START_TIME: {
				if(otherTaskList[row]->getStartTime()!=NULL){
					std::string taskStartTime = otherTaskList[row]->getStartTime()->toString();
					QString qStartTime = QString::fromStdString(taskStartTime);
					item = new QStandardItem(qStartTime);
				}
				break;
			}
			case COLUMN_END_DATE: {
				if(otherTaskList[row]->getEndDate()!=NULL){
					std::string taskEndDate = otherTaskList[row]->getEndDate()->toString();
					QString qEndDate = QString::fromStdString(taskEndDate);
					item = new QStandardItem(qEndDate);
				}
				break;
			}
			case COLUMN_END_TIME: {
				if(otherTaskList[row]->getEndTime()!=NULL){
					std::string taskEndTime = otherTaskList[row]->getEndTime()->toString();
					QString qEndTime = QString::fromStdString(taskEndTime);
					item = new QStandardItem(qEndTime);
				}
				break;
			}
			case COLUMN_CATEGORY: {
				if(otherTaskList[row]->getTaskCategory()!=""){
					std::string taskCategory= otherTaskList[row]->getTaskCategory();
					QString qCategory = QString::fromStdString(taskCategory);
					item = new QStandardItem(qCategory);
				}
				break;
			}
			default: {
				ui.label_mlog->setText(OUT_OF_BOUNDS);	
			}
			}
			model->setItem(row, column, item);

			highlightOthers(otherTaskList, row, column);
			boldOthers(boldedIndices, row, column);
		}
	}
}

//highlight rows in red if status of that task is overdue, in green is status is done, and in yellow if status is clashed.
void TimeWiseGUI::highlightOthers(std::vector<Task*>& otherTaskList, int row, int column) {
	TASK_STATUS taskStatus = otherTaskList[row]->getTaskStatus();
	QString qStatus = QString::fromStdString(TASK_STATUS_STRING[taskStatus]);
	QColor rowColorOverdue(OVERDUE_R_INDEX, OVERDUE_G_INDEX, OVERDUE_B_INDEX, OVERDUE_TRANSPARENCY_INDEX);
	QColor rowColorComplete(COMPLETED_R_INDEX, COMPLETED_G_INDEX, COMPLETED_B_INDEX);
	QColor rowColorClash(CLASH_R_INDEX, CLASH_G_INDEX, CLASH_B_INDEX); 

	//Overdue and Completed status take precedence over Clash status
	//(i.e. if a task is overdue and clashed, highlight it red)
	bool checkClash = otherTaskList[row]->isClash();
	if(qStatus == OVERDUE_STATUS && checkClash) {
		model->setData(model->index(row, column), rowColorOverdue, Qt::BackgroundRole);
	} else if (qStatus == DONE_STATUS && checkClash) {
		model->setData(model->index(row, column), rowColorComplete, Qt::BackgroundRole);
	} else if (checkClash) {
		model->setData(model->index(row, column), rowColorClash, Qt::BackgroundRole);
	} else if (qStatus == OVERDUE_STATUS) {
		model->setData(model->index(row, column), rowColorOverdue, Qt::BackgroundRole);
	} else if (qStatus == DONE_STATUS) {
		model->setData(model->index(row, column), rowColorComplete, Qt::BackgroundRole);
	}
}

//bolds entire task if it is the latest task added/edited. Also bolds existing task(s) that clashes with new task added/edited.
void TimeWiseGUI::boldOthers(vector<int> &boldedIndices, int row, int column) {
	QFont font;
	font.setBold(false);
	for(int i = 0; i < boldedIndices.size(); i++) {
		if(row == boldedIndices[i]) {
			font.setWeight(BOLDEST);
			font.setPointSize(BOLDED_FONT_SIZE);
		} 
	}
	model->setData(model->index(row,column), font, Qt::FontRole);
}

//=====================================================
//             TABLE INITIAL CONFIGURATION
//=====================================================
void TimeWiseGUI::configureTable() {
	//creates model and names column header titles
	model = new QStandardItemModel (NOUGHT, COLUMN_COUNT, this);
	model->setHorizontalHeaderItem(COLUMN_DESCRIPTION, new QStandardItem(QString(DESCRIPTION_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_DAY, new QStandardItem(QString(DAY_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_START_DATE, new QStandardItem(QString(START_DATE_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_START_TIME, new QStandardItem(QString(START_TIME_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_END_DATE, new QStandardItem(QString(END_DATE_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_END_TIME, new QStandardItem(QString(END_TIME_HEADER)));
	model->setHorizontalHeaderItem(COLUMN_CATEGORY, new QStandardItem(QString(CAT_HEADER)));
	createMainTable();
	ui.tableView->setModel(model);

	//set column widths of table.
	ui.tableView->setColumnWidth(COLUMN_DESCRIPTION, COLUMN_DESC_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_DESCRIPTION, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_DAY, COLUMN_DAY_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_DAY, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_START_DATE, COLUMN_START_DATE_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_START_DATE, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_START_TIME, COLUMN_START_TIME_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_START_TIME, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_END_DATE, COLUMN_END_DATE_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_END_DATE, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_END_TIME, COLUMN_END_TIME_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_END_TIME, QHeaderView::Fixed);
	ui.tableView->setColumnWidth(COLUMN_CATEGORY, COLUMN_CATEGORY_WIDTH);
	ui.tableView->horizontalHeader()->setSectionResizeMode(COLUMN_CATEGORY, QHeaderView::Stretch);

	ui.tableView->setMinimumWidth(TOTAL_WIDTH);
	ui.tableView->setMaximumWidth(TOTAL_WIDTH);

	//set up row heights of table.
	ui.tableView->verticalHeader()->setDefaultSectionSize(ROW_HEIGHT);

	//allows long texts to be wrapped.
	ui.tableView->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
	
	ui.tableView->setSelectionMode(QAbstractItemView::NoSelection);
}

//=====================================================
//                 CLOCK SET-UP
//=====================================================
void TimeWiseGUI::setupClock() {	
	_clock = new TimeWiseClock();
	ui.label_date->setText(_clock->dateToString());
	ui.label_time->setText(_clock->timeToString());

	QTimer *timer = new QTimer(this);
	connect(timer, SIGNAL(timeout()), this, SLOT( updateTime() ));
	timer->start();
}

void TimeWiseGUI::updateTime() {
	_clock = new TimeWiseClock();
	ui.label_date->setText(_clock->dateToString());
	ui.label_time->setText(_clock->timeToString());

	if(_logic.getTaskList().checkNewOverdue()){
		_logic.getTaskList().updateOverdueTaskList();
		if(_logic.getScreenToDisplay() == MAIN){
			createMainTable();
		}
	}
}

//=====================================================
//                FONTS SET-UP 
//=====================================================
void TimeWiseGUI::setupFont() {
	QFontDatabase fontDatabase; 
	fontDatabase.addApplicationFont(FONT_CF_JACK_STORY);
	fontDatabase.addApplicationFont(FONT_EHSMB);
	fontDatabase.addApplicationFont(FONT_NEW_CICLE);

	ui.label_date->setFont(QFont(FONT_EHSMB_NAME, DATE_SIZE, BOLD));
	ui.label_time->setFont(QFont(FONT_EHSMB_NAME, TIME_SIZE, BOLD));
}

//=====================================================
//                HOTKEYS SET-UP
//=====================================================
void TimeWiseGUI::setupHotKeys() {
	QShortcut *shortcutUndo = new QShortcut(QKeySequence(HOTKEY_F3), this);
	QShortcut *shortcutRedo = new QShortcut(QKeySequence(HOTKEY_F4), this);
	QShortcut *shortcutMain = new QShortcut(QKeySequence(HOTKEY_F1), this);
	QShortcut *shortcutDone = new QShortcut(QKeySequence(HOTKEY_F2), this);
	QObject::connect(shortcutUndo, SIGNAL(activated()), this, SLOT(undo()));
	QObject::connect(shortcutRedo, SIGNAL(activated()), this, SLOT(redo()));
	QObject::connect(shortcutMain, SIGNAL(activated()), this, SLOT(displayMain()));
	QObject::connect(shortcutDone, SIGNAL(activated()), this, SLOT(displayDone()));
}

//undo slot for undo shortcut
void TimeWiseGUI::undo() {
	std::string messageLog = _logic.processCommand(UNDO_COMMAND);
	QString outputMessage = QString::fromStdString(messageLog);
	ui.label_mlog->setText(outputMessage);

	DISPLAY_TYPE displayType = _logic.getScreenToDisplay();
	displayTaskList(displayType);
}

//redo slot for redo shortcut
void TimeWiseGUI::redo() {
	_logic.processCommand(REDO_COMMAND);

	DISPLAY_TYPE displayType = _logic.getScreenToDisplay();
	displayTaskList(displayType);
}

//displayMain slot for shortcut to display main list
void TimeWiseGUI::displayMain() {
    ui.label_title->setText(MAIN_TITLE);

	_logic.processCommand(DISPLAY_MAIN);
	createMainTable();
}

//displayDone slot for shortcut to display done list
void TimeWiseGUI::displayDone() {
	ui.label_title->setText(COMPLETED_TITLE);
	
	_logic.processCommand(DISPLAY_DONE);
	vector<Task*> taskList = _logic.getTaskList().getCompletedTaskList();
	createOtherTables(taskList);
}

//=====================================================
//            OVERDUE TASKS COUNT REMINDER
//=====================================================
void TimeWiseGUI::setOverdueMessage() {
	int overdues = countNumberOfOverdues();
	if(overdues > 0) {
		sprintf_s(buffer, OVERDUE_REMINDER.c_str(), overdues);
		QString qOverdue = QString::fromStdString(buffer);
		ui.label_mlog->setText(qOverdue);
	}
}

int TimeWiseGUI::countNumberOfOverdues() {
	TaskList taskList = _logic.getTaskList();
	std::vector<Task*> overdueTaskList = taskList.getOverdueTaskList();
	int overdueTasksCount = overdueTaskList.size(); 
	return overdueTasksCount;
}

//=====================================================
//                 AUTO-COMPLETER
//=====================================================
void TimeWiseGUI::autoComplete() {
	QStringList autocompleteList;
	TaskList taskList = _logic.getTaskList();

	//for search function
	for(int i = 0; i < taskList.undoneSize(); i++) {
		ostringstream outstrDesc;
		outstrDesc << SEARCH_COMMAND << SPACE << taskList.getTask(i)->getDescription();
		QString qDesc = QString::fromStdString(outstrDesc.str());
		autocompleteList << qDesc;
	}

	//for display function
	autocompleteList << DISPLAY_DONE << DISPLAY_MAIN;

	//for clear function
	autocompleteList << CLEAR_COMMAND << CLEAR_ALL << CLEAR_MAIN << CLEAR_COMPLETED;

	_autoCompleter = new QCompleter(autocompleteList, this);
	_autoCompleter->setCaseSensitivity(Qt::CaseInsensitive);
	ui.userInput->setCompleter(_autoCompleter);
}

//=====================================================
//           KEY-PRESSED EVENTS FOR USER INPUT BOX
//=====================================================
//enables user to press certain keys (up, down, home) while 
//focus is at user input box to do specific tasks.
//Pressing up will retrieve previous line of input.
//Pressing down will retrieve next line of input.
//Pressing home will bring focus away to table.

bool TimeWiseGUI::eventFilter(QObject* obj, QEvent *event) {
	if (obj == ui.userInput) {
		if (event->type() == QEvent::KeyPress) {
			QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
			if (keyEvent->key() == Qt::Key_Up) {
				goToPreviousLine();
				return true;
			} else if(keyEvent->key() == Qt::Key_Down) {
				goToNextLine();
				return true;
			} else if(keyEvent->key() == Qt::Key_Home) {
				ui.tableView->setFocus();
				return true;
			}
		}
		return false;
	} 
	return QMainWindow::eventFilter(obj, event);
}

void TimeWiseGUI::goToPreviousLine() {
	if (lines.empty()) {
		return;
	}

	if (!ui.userInput->text().isEmpty() 
		&& ( current_line >= lines.size() || ui.userInput->text() != lines[current_line])) {
		unfinished = ui.userInput->text();
	}
	if (current_line > NOUGHT) {
		current_line--;
	}
	ui.userInput->setText(lines[current_line]);
	ui.userInput->selectAll();
}

void TimeWiseGUI::goToNextLine() {
	if (lines.empty()) {
		return;
	}

	current_line++;

	if (current_line >= lines.size()) {
		ui.userInput->setText(unfinished);
		unfinished = BLANK;
		current_line = lines.size();
	} else {
		ui.userInput->setText(lines[current_line]);
		ui.userInput->selectAll();
	}
}

//=====================================================
//                HELP PAGE SET-UP
//=====================================================
void TimeWiseGUI::showHelp() {
	_helpScreen = new TimeWiseHelp();
	_helpScreen->show();
}

//=====================================================
//                OTHER FUNCTIONS
//=====================================================
void TimeWiseGUI::checkCorrupted() {
	if(_logic.isCorruptedStorage()) {
		ui.label_mlog->setText(CORRUPTED_MESSAGE);
	}
}

//Throws exception if user does not key in anything into command input box
void TimeWiseGUI::checkEmpty(QString input){
	if(input.size() == NOUGHT) {
		throw std::invalid_argument(EMPTY_INPUT);
	}
}


	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewisegui.cpp





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewisegui.h
	 */

#ifndef TIMEWISEGUI_H
#define TIMEWISEGUI_H

#include <iostream>
#include <QCompleter>
#include <QDateTime>
#include <QHeaderView>
#include <QFont>
#include <QFontDatabase>
#include <QKeyEvent>
#include <QLineEdit>
#include <QShortcut>
#include <QStandardItemModel>
#include <QString>
#include <QTimer>
#include <QtWidgets/QMainWindow>
#include <stdio.h>
#include <stdexcept>
#include <string>
#include "ui_timewisegui.h"
#include "Constants_ui.h"
#include "TimeWiseClock.h"
#include "timewisehelp.h"
#include "TimeWiseLogic.h"

class TimeWiseGUI : public QMainWindow {
	Q_OBJECT

public:
	TimeWiseGUI(QWidget *parent = 0);
	~TimeWiseGUI();
	QStandardItemModel *model;
	void configureTable();
	void setupClock();
	void setupFont();
	void setupHotKeys();
	
	//These are the functions that sets the data (main page and other pages separate functions) from Logic into table
	void displayTaskList(DISPLAY_TYPE displayType);
	void createMainTable();
	void setMainData(TaskList& tasklist, vector<int>& latestIndices);
	void highlightMain(TaskList &taskList, int row, int column, vector<int> &boldedIndices);
	void boldMain(vector<int> &boldedIndices, int row, int column); 

	void createOtherTables(std::vector<Task*>& taskList);
	void setOtherData(std::vector<Task*>& otherTaskList, vector<int>& latestIndices);
	void boldOthers(vector<int> &boldedIndices, int row, int column);
	void highlightOthers( std::vector<Task*>& otherTaskList, int row, int column);

	//These are the functions that inform user of the number of overdue tasks.
	void setOverdueMessage();
	int countNumberOfOverdues();

	//These are the functions that allow lineEdit to retrieve previous user actions
	bool eventFilter(QObject* obj, QEvent *event);
	void goToPreviousLine();
	void goToNextLine();

	//other functions
	void autoComplete();
	void checkCorrupted();
	void checkEmpty(QString input);
	void showHelp();

private slots:
	void updateTime();
	void on_userInput_textChanged();
	void on_userInput_returnPressed();
	void undo();
	void redo();
	void displayDone();
	void displayMain();

signals:
    void lineExecuted(QString);

private:
	Ui::TimeWiseGUIClass ui;
	TimeWiseClock *_clock;
	TimeWiseHelp *_helpScreen;
	TimeWiseLogic _logic;
	QCompleter *_autoCompleter;
	
	//these are for the history retrieval used in line Edit
	int current_line;
	QStringList lines;
	QString unfinished;
};
#endif // TIMEWISEGUI_H

	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewisegui.h





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewisehelp.cpp
	 */

#include "timewisehelp.h"

TimeWiseHelp::TimeWiseHelp(QWidget *parent) : QWidget(parent) {
	ui.setupUi(this);
	this->setWindowFlags(Qt::CustomizeWindowHint); //remove title header of help window
	ui.textEdit->scrollToAnchor(SPACE);            //set help window to scroll to the top upon initialization (else window will be scrolled to bottom)
	ui.pushButton_ok->setFocus();				   //bring focus to ok button so that user can press Enter and leave the page immediately.
}

TimeWiseHelp::~TimeWiseHelp() {
}

//overrides dialog widget's stylesheet configuration (put simply, allow background of pop-up box to be set)
void TimeWiseHelp::paintEvent(QPaintEvent *pe) {                                                                                                                                        
	QStyleOption o;                                                                                                                                                                  
	o.initFrom(this);                                                                                                                                                                
	QPainter p(this);                                                                                                                                                                
	style()->drawPrimitive(QStyle::PE_Widget, &o, &p, this);                                                                                                                         
}
	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewisehelp.cpp





	/**
	 * origin: D:\TiMEWiSE\TimeWiseGUI\timewisehelp.h
	 */

#ifndef TIMEWISEHELP_H
#define TIMEWISEHELP_H

#include <QFontDatabase>
#include <QPainter>
#include <QWidget>
#include "ui_timewisehelp.h"
#include "Constants_ui.h"
//============================================================
// This class is responsible for configuring a help-guide 
// object that is displayed when user keys in 'help' in main ui.
//============================================================

class TimeWiseHelp : public QWidget {
	Q_OBJECT

public:
	TimeWiseHelp(QWidget *parent = 0);
	~TimeWiseHelp();
	void paintEvent(QPaintEvent *pe);

private:
	Ui::TimeWiseHelp ui;

};
#endif TIMEWISEHELP_H

	// End of segment: D:\TiMEWiSE\TimeWiseGUI\timewisehelp.h





